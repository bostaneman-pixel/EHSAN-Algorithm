import numpy as np
import time

# =======================================================
#   Truss 25-Bar FEM + Penalty 
# =======================================================

class Truss25BarProblem:
    def __init__(self):
        self.E = 10000.0
        self.rho = 0.1

        self.stress_limit = 250.0   # از تست A=5
        self.disp_limit   = 15.0

        self.num_variables = 25
        self.area_groups = [
            [0, 1], [2, 3, 4, 5], [6, 7, 8, 9],
            [10, 11, 12, 13], [14, 15, 16, 17],
            [18, 19, 20, 21], [22, 23, 24]
        ]
        self.num_design_variables = 7

        # بازهٔ مساحت‌ها
        self.bounds = [(0.5, 5.0)] * self.num_design_variables
        self.Penalty_Factor = 1e4

        self.nodes = np.array([
            [0, 0], [0, 100], [0, 200],
            [100, 0], [100, 100], [100, 200],
            [200, 0], [200, 100], [200, 200],
            [300, 0], [300, 100], [300, 200]
        ], dtype=float)

        self.elements = [
            (0, 4), (1, 3),
            (1, 5), (2, 4),
            (3, 7), (4, 6),
            (4, 8), (5, 7),
            (6, 10), (7, 9),
            (7, 11), (8, 10),
            (0, 3), (1, 4), (2, 5),
            (3, 6), (4, 7), (5, 8),
            (6, 9), (7, 10), (8, 11),
            (0, 1), (1, 2),
            (9, 10), (10, 11)
        ]

        self.fixed_dofs = [0, 1, 6, 7, 12, 13]

        self.loads = np.zeros(2 * len(self.nodes))
        self.loads[2*11 + 1] = -1000  # بار روی گره بالایی سمت راست

        self.lengths = np.array([
            np.linalg.norm(self.nodes[n2] - self.nodes[n1])
            for (n1, n2) in self.elements
        ])

    def calculate_weight(self, A_all):
        return np.sum(self.rho * self.lengths * A_all)

    def fem_solver(self, A_all):
        num_nodes = len(self.nodes)
        dof = 2 * num_nodes
        K = np.zeros((dof, dof))
        E = self.E

        for e, (n1, n2) in enumerate(self.elements):
            x1, y1 = self.nodes[n1]
            x2, y2 = self.nodes[n2]
            L = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
            cx = (x2 - x1) / L
            cy = (y2 - y1) / L
            A = A_all[e]
            k_local = (E * A / L) * np.array([
                [ cx*cx,  cx*cy, -cx*cx, -cx*cy],
                [ cx*cy,  cy*cy, -cx*cy, -cy*cy],
                [-cx*cx, -cx*cy,  cx*cx,  cx*cy],
                [-cx*cy, -cy*cy,  cx*cy,  cy*cy]
            ])
            dofs = [2*n1, 2*n1+1, 2*n2, 2*n2+1]
            for i in range(4):
                for j in range(4):
                    K[dofs[i], dofs[j]] += k_local[i, j]

        F = self.loads.copy()
        free = np.setdiff1d(np.arange(dof), self.fixed_dofs)
        K_ff = K[np.ix_(free, free)]
        F_ff = F[free]

        u = np.zeros(dof)
        u[free] = np.linalg.solve(K_ff, F_ff)

        stresses = np.zeros(len(self.elements))
        for e, (n1, n2) in enumerate(self.elements):
            x1, y1 = self.nodes[n1]
            x2, y2 = self.nodes[n2]
            L = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
            cx = (x2 - x1) / L
            cy = (y2 - y1) / L
            dofs = [2*n1, 2*n1+1, 2*n2, 2*n2+1]
            ue = u[dofs]
            A = A_all[e]
            N = (E * A / L) * np.array([-cx, -cy, cx, cy]).dot(ue)
            stresses[e] = N / A

        return u, stresses

    def objective_function(self, design_variables):
        A_all = np.zeros(self.num_variables)
        for g, idxs in enumerate(self.area_groups):
            for i in idxs:
                A_all[i] = design_variables[g]

        F_weight = self.calculate_weight(A_all)
        displacements, stresses = self.fem_solver(A_all)

        violation_stress = np.sum(np.maximum(0, np.abs(stresses) - self.stress_limit))
        violation_disp   = np.sum(np.maximum(0, np.abs(displacements) - self.disp_limit))

        F_penalized = F_weight + self.Penalty_Factor * (violation_stress + violation_disp)
        return F_penalized, F_weight, violation_stress, violation_disp


# =======================================================
#   EHSAN Optimizer V1.3
# =======================================================

class EHSANOptimizerV1_3:
    def __init__(self, obj_func, bounds, pop_size=50, generations=120, max_evals=8000):
        self.obj_func = obj_func
        self.bounds = np.array(bounds)
        self.dim = len(bounds)
        self.lb = self.bounds[:, 0]
        self.ub = self.bounds[:, 1]
        self.pop_size = pop_size
        self.generations = generations
        self.max_evals = max_evals

    def initialize(self):
        self.pop = np.random.uniform(self.lb, self.ub, (self.pop_size, self.dim))
        self.fits = np.array([self.obj_func(p) for p in self.pop])
        self.best_x = self.pop[np.argmin(self.fits)].copy()
        self.best_f = np.min(self.fits)
        self.eval_count = self.pop_size

    def run(self):
        self.initialize()
        for gen in range(self.generations):
            if self.eval_count >= self.max_evals:
                break
            t = gen / max(1, (self.generations - 1))
            new_pop = self.pop.copy()
            new_fits = self.fits.copy()
            for i in range(self.pop_size):
                Xi = self.pop[i]
                C1 = 0.4 * np.random.rand()
                C2 = 0.5 * (1 - t) * np.random.rand()
                C3 = (0.05 + 0.15 * t) * np.random.rand()
                Exploitation = C1 * (self.best_x - Xi)
                r1, r2 = np.random.choice(self.pop_size, 2, replace=False)
                Xr1, Xr2 = self.pop[r1], self.pop[r2]
                Exploration = C2 * (Xr1 - Xr2)
                Targeting = C3 * (self.best_x - Xi)
                mutation_scale = 0.02 * (1 - t)
                Mutation = mutation_scale * np.random.randn(self.dim)
                X_new = Xi + Exploitation + Exploration + Targeting + Mutation
                X_new = np.clip(X_new, self.lb, self.ub)
                F_new = self.obj_func(X_new)
                self.eval_count += 1
                if F_new < self.fits[i]:
                    new_pop[i] = X_new
                    new_fits[i] = F_new
                    if F_new < self.best_f:
                        self.best_f = F_new
                        self.best_x = X_new.copy()
            self.pop = new_pop
            self.fits = new_fits
        return self.best_f, self.best_x


# =======================================================
#   PSO, DE, GA (نسخه‌های بالانس‌شده)
# =======================================================

def PSO_optimize(obj_func, bounds, pop_size=50, iterations=120):
    dim = len(bounds)
    lb = np.array([b[0] for b in bounds])
    ub = np.array([b[1] for b in bounds])

    X = np.random.uniform(lb, ub, (pop_size, dim))
    V = np.zeros((pop_size, dim))

    pbest = X.copy()
    pbest_f = np.array([obj_func(x) for x in X])

    gbest = pbest[np.argmin(pbest_f)].copy()
    gbest_f = np.min(pbest_f)

    w = 0.7
    c1 = 1.4
    c2 = 1.4

    for it in range(iterations):
        r1 = np.random.rand(pop_size, dim)
        r2 = np.random.rand(pop_size, dim)

        V = w*V + c1*r1*(pbest - X) + c2*r2*(gbest - X)
        X = X + V
        X = np.clip(X, lb, ub)

        fits = np.array([obj_func(x) for x in X])

        better = fits < pbest_f
        pbest[better] = X[better]
        pbest_f[better] = fits[better]

        if np.min(fits) < gbest_f:
            gbest = X[np.argmin(fits)].copy()
            gbest_f = np.min(fits)

    return gbest_f, gbest


def DE_optimize(obj_func, bounds, pop_size=50, iterations=120, F=0.5, CR=0.7):
    dim = len(bounds)
    lb = np.array([b[0] for b in bounds])
    ub = np.array([b[1] for b in bounds])

    pop = np.random.uniform(lb, ub, (pop_size, dim))
    fits = np.array([obj_func(x) for x in pop])

    for it in range(iterations):
        for i in range(pop_size):
            a, b, c = np.random.choice(pop_size, 3, replace=False)
            mutant = pop[a] + F*(pop[b] - pop[c])
            mutant = np.clip(mutant, lb, ub)

            cross = np.random.rand(dim) < CR
            if not np.any(cross):
                cross[np.random.randint(dim)] = True

            trial = np.where(cross, mutant, pop[i])
            f_trial = obj_func(trial)

            if f_trial < fits[i]:
                pop[i] = trial
                fits[i] = f_trial

    best_idx = np.argmin(fits)
    return fits[best_idx], pop[best_idx]


def GA_optimize(obj_func, bounds, pop_size=50, iterations=120, mutation_rate=0.1):
    dim = len(bounds)
    lb = np.array([b[0] for b in bounds])
    ub = np.array([b[1] for b in bounds])

    pop = np.random.uniform(lb, ub, (pop_size, dim))
    fits = np.array([obj_func(x) for x in pop])

    for it in range(iterations):
        idx = np.argsort(fits)
        pop = pop[idx]
        fits = fits[idx]

        parents = pop[:pop_size//2]

        children = []
        for _ in range(pop_size//2):
            p1, p2 = parents[np.random.choice(len(parents), 2, replace=False)]
            alpha = np.random.rand()
            child = alpha*p1 + (1-alpha)*p2

            if np.random.rand() < mutation_rate:
                child += 0.1*np.random.randn(dim)

            child = np.clip(child, lb, ub)
            children.append(child)

        pop = np.vstack([parents, children])
        fits = np.array([obj_func(x) for x in pop])

    best_idx = np.argmin(fits)
    return fits[best_idx], pop[best_idx]


# =======================================================
#   مقایسهٔ فوق‌بهینه (همه با FEM + penalty)
# =======================================================

def compare_algorithms(num_runs=10):
    truss = Truss25BarProblem()
    obj = lambda x: truss.objective_function(x)[0]

    stats = {
        "EHSAN": {"weights": [], "valid": 0},
        "PSO":   {"weights": [], "valid": 0},
        "DE":    {"weights": [], "valid": 0},
        "GA":    {"weights": [], "valid": 0},
    }

    start = time.time()

    for r in range(num_runs):
        print(f"\n===== Run {r+1}/{num_runs} =====")
        np.random.seed(r)

        # EHSAN
        ehsan = EHSANOptimizerV1_3(obj, truss.bounds)
        f_e, x_e = ehsan.run()
        Fp, Fw, Vs, Vd = truss.objective_function(x_e)
        if Vs < 1e-6 and Vd < 1e-6:
            stats["EHSAN"]["valid"] += 1
            stats["EHSAN"]["weights"].append(Fw)
        print(f"EHSAN: Weight={Fw:.3f}, Vs={Vs:.3f}, Vd={Vd:.3f}")

        # PSO
        f_p, x_p = PSO_optimize(obj, truss.bounds)
        Fp, Fw, Vs, Vd = truss.objective_function(x_p)
        if Vs < 1e-6 and Vd < 1e-6:
            stats["PSO"]["valid"] += 1
            stats["PSO"]["weights"].append(Fw)
        print(f"PSO  : Weight={Fw:.3f}, Vs={Vs:.3f}, Vd={Vd:.3f}")

        # DE
        f_d, x_d = DE_optimize(obj, truss.bounds)
        Fp, Fw, Vs, Vd = truss.objective_function(x_d)
        if Vs < 1e-6 and Vd < 1e-6:
            stats["DE"]["valid"] += 1
            stats["DE"]["weights"].append(Fw)
        print(f"DE   : Weight={Fw:.3f}, Vs={Vs:.3f}, Vd={Vd:.3f}")

        # GA
        f_g, x_g = GA_optimize(obj, truss.bounds)
        Fp, Fw, Vs, Vd = truss.objective_function(x_g)
        if Vs < 1e-6 and Vd < 1e-6:
            stats["GA"]["valid"] += 1
            stats["GA"]["weights"].append(Fw)
        print(f"GA   : Weight={Fw:.3f}, Vs={Vs:.3f}, Vd={Vd:.3f}")

    end = time.time()

    print("\n=========== SUMMARY (Valid solutions only) ===========")
    print(f"{'Algo':<8} | {'Valid':<7} | {'Mean W':<10} | {'Std':<8} | {'Best':<10}")
    print("-"*60)
    for algo, data in stats.items():
        ws = np.array(data["weights"])
        if len(ws) > 0:
            print(f"{algo:<8} | {data['valid']}/{num_runs:<7} | {ws.mean():<10.3f} | {ws.std():<8.3f} | {ws.min():<10.3f}")
        else:
            print(f"{algo:<8} | {data['valid']}/{num_runs:<7} | {'-':<10} | {'-':<8} | {'-':<10}")
    print(f"\nTotal Time: {end - start:.2f} sec")


# ============ اجرا ============

compare_algorithms(num_runs=10)
