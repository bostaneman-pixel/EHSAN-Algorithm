import numpy as np

class Truss25BarProblem:
    """
    25-Bar Planar Truss
    FEM + Stress/Displacement Constraints + Penalty
    Compatible with EHSANOptimizerV1_5
    """

    def __init__(self):
        # Material properties
        self.E = 10000.0
        self.rho = 0.1

        # Allowable limits
        self.stress_limit = 250.0
        self.disp_limit = 15.0

        # 25 elements grouped into 7 design variables
        self.num_elements = 25
        self.area_groups = [
            [0, 1],                 # A1
            [2, 3, 4, 5],           # A2
            [6, 7, 8, 9],           # A3
            [10, 11, 12, 13],       # A4
            [14, 15, 16, 17],       # A5
            [18, 19, 20, 21],       # A6
            [22, 23, 24]            # A7
        ]
        self.num_design_variables = 7

        # Bounds for each design variable
        self.bounds = [(0.5, 5.0)] * self.num_design_variables

        # Penalty factor
        self.P = 1e4

        # Node coordinates
        self.nodes = np.array([
            [0, 0], [0, 100], [0, 200],
            [100, 0], [100, 100], [100, 200],
            [200, 0], [200, 100], [200, 200],
            [300, 0], [300, 100], [300, 200]
        ], dtype=float)

        # Element connectivity
        self.elements = [
            (0, 4), (1, 3),
            (1, 5), (2, 4),
            (3, 7), (4, 6),
            (4, 8), (5, 7),
            (6, 10), (7, 9),
            (7, 11), (8, 10),
            (0, 3), (1, 4), (2, 5),
            (3, 6), (4, 7), (5, 8),
            (6, 9), (7, 10), (8, 11),
            (0, 1), (1, 2),
            (9, 10), (10, 11)
        ]

        # Fixed DOFs
        self.fixed_dofs = [0, 1, 6, 7, 12, 13]

        # External load
        self.loads = np.zeros(2 * len(self.nodes))
        self.loads[2*11 + 1] = -1000  # downward load at node 11 (top-right)

        # Precompute element lengths
        self.lengths = np.array([
            np.linalg.norm(self.nodes[n2] - self.nodes[n1])
            for (n1, n2) in self.elements
        ])

    # ---------------------------------------------------------
    # Weight
    # ---------------------------------------------------------
    def calculate_weight(self, A_all):
        return np.sum(self.rho * self.lengths * A_all)

    # ---------------------------------------------------------
    # FEM solver
    # ---------------------------------------------------------
    def fem_solver(self, A_all):
        num_nodes = len(self.nodes)
        dof = 2 * num_nodes
        K = np.zeros((dof, dof))
        E = self.E

        # Assemble global stiffness matrix
        for e, (n1, n2) in enumerate(self.elements):
            x1, y1 = self.nodes[n1]
            x2, y2 = self.nodes[n2]
            L = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
            cx = (x2 - x1) / L
            cy = (y2 - y1) / L
            A = A_all[e]

            k_local = (E * A / L) * np.array([
                [ cx*cx,  cx*cy, -cx*cx, -cx*cy],
                [ cx*cy,  cy*cy, -cx*cy, -cy*cy],
                [-cx*cx, -cx*cy,  cx*cx,  cx*cy],
                [-cx*cy, -cy*cy,  cx*cy,  cy*cy]
            ])

            dofs = [2*n1, 2*n1+1, 2*n2, 2*n2+1]
            for i in range(4):
                for j in range(4):
                    K[dofs[i], dofs[j]] += k_local[i, j]

        # Apply boundary conditions
        F = self.loads.copy()
        free = np.setdiff1d(np.arange(dof), self.fixed_dofs)
        K_ff = K[np.ix_(free, free)]
        F_ff = F[free]

        # Solve displacements
        u = np.zeros(dof)
        u[free] = np.linalg.solve(K_ff, F_ff)

        # Compute stresses
        stresses = np.zeros(self.num_elements)
        for e, (n1, n2) in enumerate(self.elements):
            x1, y1 = self.nodes[n1]
            x2, y2 = self.nodes[n2]
            L = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
            cx = (x2 - x1) / L
            cy = (y2 - y1) / L
            dofs = [2*n1, 2*n1+1, 2*n2, 2*n2+1]
            ue = u[dofs]
            A = A_all[e]
            N = (E * A / L) * np.array([-cx, -cy, cx, cy]).dot(ue)
            stresses[e] = N / A

        return u, stresses

    # ---------------------------------------------------------
    # Objective function (weight + penalty)
    # ---------------------------------------------------------
    def objective_function(self, x):
        # Expand 7 design variables â†’ 25 element areas
        A_all = np.zeros(self.num_elements)
        for g, idxs in enumerate(self.area_groups):
            for i in idxs:
                A_all[i] = x[g]

        weight = self.calculate_weight(A_all)
        disp, stress = self.fem_solver(A_all)

        # Constraint violations
        v_stress = np.sum(np.maximum(0, np.abs(stress) - self.stress_limit))
        v_disp   = np.sum(np.maximum(0, np.abs(disp) - self.disp_limit))

        penalty = self.P * (v_stress + v_disp)
        return weight + penalty
